rule EntryExtractor
    transform m : Source!Model 
    to mNew : Target!Model {
    
	mNew.name = m.name;
	
	var ids = new Map<Property>();
	
	for(p in m.packagedElement.select(mo|mo.isTypeOf(Source!Package))) {
		var pNew = new Target!Package();		
		pNew.name = p.name;
	
		for(cl in p.packagedElement.select(pe|pe.isTypeOf(Source!Class))) {
			if(cl.appliedStereotypes.select(s|s.name=="Entry" or s.name=="SuperClass").size!=0) {
				var clNew = new Target!Class();
				// add name
				clNew.name = cl.name;
				clNew.visibility = cl.visibility;
				
				// add generalization
				for(gen in cl.generalization) {
					var generalization = new Target!Generalization();
					generalization.general = gen.general;
					clNew.generalization.add(generalization);
				}
				
				// add attributes
				for(attr in cl.ownedAttribute) {
					var property = new Target!Property();
					property.name = attr.name;
					property.visibility = attr.visibility;
					property.type = attr.type;
					clNew.ownedAttribute.add(property);
					ids.put(attr, property);
				}
				
				// add methods
				for(op in cl.ownedOperation) {
					var method = new Target!Operation();
					method.name = op.name;
					method.visibility = op.visibility;
					
					for(param in op.ownedParameter) {
						var parameter = new Target!Parameter();
						parameter.name = param.name;
						parameter.direction = param.direction;
						parameter.type = param.type;
						method.ownedParameter.add(parameter);
					}
					
					clNew.ownedOperation.add(method);
				}
				pNew.packagedElement.add(clNew);
			}
		}
		for(ass in m.packagedElement.select(mo|mo.isTypeOf(Source!Association))) {
			var assNew = new Target!Association();
			assNew.name = ass.name;
			assNew.memberEnd = ass.memberEnd;
			assNew.visibility = ass.visibility;
			assNew.memberEnd.println();
			
			for(prop in ass.memberEnd) {
				assNew.memberEnd.add(ids.get(prop));
			}
			
			m.packagedElement.add(assNew); 
		}
		
		mNew.packagedElement.add(pNew);
	}
}